### 1. Зависимость фреймворка.
У нас на проекте используется паттерн Messaging, входящие сообщения сохраняются в БД для последующей обработки.  И есть сервис, который извлекает эти сообщения из БД, определяет тип, и передает сообщение конкретному обработчику. И хотя он вызывает каждый из обработчиков, сам он от них не зависит.

Также возможно подойдет в качестве примера паттерн Observer. Объект вызывает Наблюдателя, но при этом не зависит от него. 

### 2. Зависимость расшаренного формата.
В статье упоминался случай, когда клиент посылает сообщения на сервер по API, и в случае если один из них поеняет формат, другой сломается.
У нас на проекте в некоторых случаях для решения такой проблемы используется подход, когда в сообщении json есть некоторые фиксированные поля (например source, status), и есть поле data (в формате json), которое хранит часть сообщения, которая может меняться.
Поэтому если, например, клиент изменит формат только json в этом поле, сервер не сломается. 


### 3. Зависимость зависимости.
Сервис A вызывает сервис B, и делает расчеты на основе полученных данных. Сервис C ежедневно по расписанию отправляет данные в B. Если С перестанет отправлять данные, то расчеты в A сломаются, хотя A вроде никак не зависит от С. 

### 4. Зависимость краша.


### 5. Зависимость перебрасывания.
Тут возможно подойдет пример, когда сервис А обращается к B, а в случае, если В недоступен, обращается вместо этого к своему кэшу. 
Но если кэш устарел, то обращение к нему вернет не то, что на самом деле лежит в В. Поэтому B все равно зависит от A. 

### 6. Зависимость инверсии.
На рабочих проектах со Spring-ом, часто бывала ситуация, когда бин Спринга имеет зависимость на некий интерфейс, а это интерфейс имеет очень много реализаций. 
И становится сложно даже просто понять, как это работает в рантайме. Сколько бинов создается, какие реализации инжектируются в качестве зависимостей.
У меня такое бывает, когда хочется не просто реализовать задачу, а сделать какое-то "универальное" решение, с прицелом на будущее.
Чтобы решить эту проблему, интуитивно пытаюсь декомпозировать бины, чтобы они были не слишком большими и не делали слишком много. 
И если получается, что у интерфейса который я инжектирую в бин, есть всего одна реализация, и других больше не предвидится, я напрямую инжектирую класс, а не интерфейс.

### 7. Зависимость зацикливания.

"A зависит от B, а B зависит от A. Что это значит для A - зависеть от A?"

Тут возможно подойдет такой пример:

В нашей системе есть сервис A, который подключается к серверу B и создает сессию для обмена сообщениями. B-сервер, согласно своей спецификации, может поддерживать только 1 сессию с определенным ID. Для всей нашей системы выдан только один ID. Но у сервиса A есть и другие задачи помимо интеграции с B. И мы бы хотели ускорить их обработку, запустив 2 экземпляра сервиса A (2 пода в openshift). Но когда мы запускаем 2 экземпляра, наше соединение с B-сервером обрывается, т.к. создается 2 сессии с одним и тем же ID. Так А влияет на самого себя.
Для решения этой проблемы создала переменную-флаг в сервисе A, которая задается в config map, и может отключать интеграцию с B-сервером. На одном экземпляре включаем флаг, на другом выключаем. Это было сделано сознательно в ходе обсуждения с коллегами. 

### 8. Зависимость высшего порядка.

Думаю, в качестве примера можно привести аннотации в Spring, например, @Transactional. 
AOP в Spring работает с использованием прокси, поэтому, если метод с аннотацией вызывается из метода того же класса, аннотация не сработает:
```
@Component
class Example {
    
    public void methodA() {
        methodB();
    }
    
    @Transactional
    public void methodB() {
        ...
    }
}
```
Такую проблему обычно решаю вынесением метода methodB в отдельный класс. Это было сознательно, т.к. читала о таком приеме.  


### 8. Зависимость большинства. 
