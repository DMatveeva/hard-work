Задача: Подбрать три случая в проектах, где вместо передачи сущностей по ссылке явно удобнее использовать 
   иммутабельные состояния.

   
В качестве примеров хотела бы привести классы из проекта "3 в ряд", который делала для курса ООАП-3.
Т.к. изначально первым побуждением было сделать все мутабельным. Но во время работы над проектом старалась руководствововаться статьей, и некоторые классы сделала иммутабельными.

1.

В проекте есть класс Cell. 

Cell - клетка матрицы. Клетка "Закрашена" каким-то цветом.

В качестве цвета - поле value типа Letter, которое представляет собой Enum: A, B, C, D, E, O (пустой цвет).

Во время этапа определения АТД изначально я определила АТД Cell с единственной командой - updateValue(Letter l), которая обновляет цвет клетки.

Реализацию я начала так:
```
public class Cell {

    private Letter value;
    private final CartesianCoordinate coordinate;

    public Cell(Letter letter) {
        this.value = letter;
    }

    public boolean isEmpty() {
        return value == Letter.O;
    }

    public void updateValue(Letter value) {...}
  
}
```
Изначально я хотела сделать, чтобы класс Cell содержал и координату, и само значение Letter. 
Но когда я прочитала завершающее занятие курса ООАП-3, где была рекомендация избегать запутанного манипулирования ссылками и использовать стандартные структуры данных, 
мне пришло в голову, что для реализации моего хранилища клеток (АТД Cells) можно использовать LinkedHashMap, где в качестве ключа будет Координата, а в качестве значения - клетка. 

В результате, чтобы поменять клетки местами, оказалось не нужно изменять саму клетку, т.к. хэшмап просто менял value для ключей. 

```
//Cells
@Override
    public void swapValues(CartesianCoordinate from, CartesianCoordinate to) {
        ...
        Cell fromCell = cells.get(from);
        Cell toCell = cells.get(to);
        cells.put(from, toCell);
        cells.put(to, fromCell);
        swapValuesStatus = SWAP_VALUES_STATUS_OK;
    }
```
Обновление требовалось только при опустошении клетки. Но и тут можно было не обновлять саму клетку, найденную по ключу, а заменить value для данного ключа на "пустую клетку".
```
//Cells
 @Override
    public void fillEmptyCellsForColumn(Coordinate x, CellSlice slice) {
        for(Coordinate y: Coordinate.values()) {
            CartesianCoordinate xy = new CartesianCoordinate(x, y);
            Cell newCell = slice.getByCoordinate(xy);
            cells.put(xy, newCell);
        }
    }
```
В итоге класс Cell получился иммутабельным.

2.
CellSlice - это АТД, который представляет собой столбец или ряд ("срез клеток"), чтобы искать по столбцам и по рядам 3 одинаковых клетки в ряд.

Также хотела использовать его для заполнения пустых клеток в матрице, т.к. при реализации алгоритма удобно в каждом ряду сначала "сжать" оставшиеся непустые клетки, чтобы убрать пустые места, а потом добавить сверху клетки со случайными цветами. 

```
public class CellSlice extends AbstractFigure {

    private final LinkedHashMap<CartesianCoordinate, Cell> coordinateToCell; 

    public CellSlice(LinkedHashMap<CartesianCoordinate, Cell> cells) {
        this.coordinateToCell = new LinkedHashMap<>(cells);
    }
    //команды
    public void squash() {} // "сжать" непустые клетки
    public void fillEmpty() {} // заполнить пустые клетки

    ...
```
Но для обновления матрицы мне нужно было работать не с одним объектом `CellSlice`, а с множеством `Set<CellSlice>` (т.к. столбцов 8).
Согласно рекомендации с курса "Быстрая прокачка в ООП", я хотела не работать с `Set<CellSlice>` напрямую, а обернуть его в собственный тип `CellSlices`. 
И получалось, что у меня будет объект `CellSlices`, у которого я хочу ограничить список операций, чтобы нельзя было непосредсвенно манипулировать 
сетом внутри, но при этом объекты, котрорые хранятся в сете, могут непредсказуемо меняться, т.к. доступны по ссылкам в другом месте.

Поэтому я решила в итоге сделать `CellSlice` тоже неизменяемым, и вместо команд 
`squash()` и `fillEmpty()` сделала запрос `copyWithEmptyCellsFilled()` который возвращает новый объект -- копию исходного объекта `CellSlice`, где клетки уже сжаты и пустые места заполенны.

В результате наш объект `CellSlices`, содержит другие объекты (`Set<CellSlice>`), но эти объекты неизменяемы. И поэтому не получится изменить внутреннюю структуру `CellSlices` из другого места.

3.
Класс Bonus - бонусы игрока.
Сначала хотела сделать его мутабельным, по сути -- контейнером для int.
```
public class Bonus {

    private int sum;

    public void add(int add) {
       sum+=add;
    }
}

Bonus bonus = new Bonus(); // sum = 0
bonus.add(5) //sum = 5
```
Но потом подумала, что можно сделать его оберткой для Int, проектным типом данным.
А контейнером сделать BonusAccount, который будет хранить бонусы. 

В новом варианте операция add не меняет объект bonus, а возвращает новый. 
```

public class Bonus {

    private final int sum;

    public Bonus(int sum) {
        this.sum = sum;
    }

    public Bonus add(Bonus bonus) {
        return new Bonus(this.sum + bonus.sum);
    }
}
```

4.

В этом пункте просто хотела бы записать свои мысли, которые возникли во время изучения статьи "Смысл данных в вашем проекте". А именно, как я пыталась для себя разобраться с понятиями мутабельности и иммутабельности. Это 
   оказалось не просто, хотя мне и казалось что я понимаю эти понятия. Но выяснилось, что не совсем.

   Когда я только начала изучать Java, и потом, когда готовилась к собеседованиям, я выучила, что иммутабельный объект - это тот, который нельзя изменить. 
Поэтому при изучении статьи мне было сложно понять новую мысль, что в иммутабельность - это в первую очередь, когда мы не можем различить два объекта, которые имеют одинаковое внутреннее содержание. 

Если бы мне раньше дали задачу, где объект Cell - иммутабельный, и спросили -- а будут равны ли эти объекты, которые доступны по ссылкам aCell_1 и aCell_2?
```
Cell aCell_1 = new Cell(A);
Cell aCell_2 = new Cell(A);
```
Я бы ответила, что это зависит от того, переопределен ли equals. Если нет, то по умолчанию "равенство" объектов 
определяется по ссылкам, а т.к. ссылки разные, то объекты не равны. 

Но теперь, после изучения статьи, я бы сказала, что они равны. А если мы не переопределили equals - то это наша ошибка. 
Потому что, цитируя статью, 
- _"Мутабельность/имутабельность - это фундаментальная концепция в программировании, которая 
выходит далеко за рамки простого обновления значений по ссылке"._
- _"Это фундаментальная концепция в программировании: у всех изменяемых сущностей имеется своя идентичность (в смысле 
"самобыстности", личной уникальности). А у иммутабельных -- нет."_(C)

Т.е. первично - это то, мутабельный объект или иммутабельный. 
И по сути мы обязаны для иммутабельных объектов переопределить equals, чтобы проверялась идентичность полей , а не 
сравнивались ссылки. 
А наш язык позволяет сделать неправильно - не переопределить equals у иммутабельных объектов. И тогда у нас просто 
будет объект, у которого 
нельзя поменять значения полей, но он не будет соответствовать концепции. Я сама должна 
реализовать свой 
класс так, 
чтобы это было в согласии с концепцией иммутабельности. 

Надеюсь, я правильно поняла здесь. Что первична фундаментальная концепция, а средства языка Java позволяют ее 
нарушить при реализации иммутабельного класса, но мы должны следить, чтобы этого не делать. 

Мне кажется, что мне было сложно это понять, потому что когда я впервые столкнулась с Java, очень много 
времени уделялось сравнению по ссылкам/по полям при переопределении equals, и это как-то стало первично в моей голове.

_"Эта схема объясняет, почему вам необходимо изменить модель данных -- чтобы явно добавить каждой сущности некий уникальный идентификатор.
Это, кстати, одна из причин, по которой правильно думать об иммутабельности как о неизменяемости по умолчанию, а о мутабельности -- как о дополнительной возможности (которая требует определённого усложнения модели)."_

А у меня изначально в голове было совсем наоборот - мутабельность по умолчанию. А вот чтобы сделать объект в Java 
иммутабельным, надо добавить много всего:
- сделать поля final
- при наличии полей - не примитивов, надо копировать объекты, передаваемые в конструкторе при инициализации  
- при наличии геттеров также возвращать копии полей, если это не примитивы

И оказалось, даже при этом объект не обязательно будет соответствовать концепции иммутабульности, ведь если мы не 
переопределим equals, то объекты будут сравниваться по ссылкам. 

